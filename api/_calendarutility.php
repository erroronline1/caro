<?php
/**
 * CARO - Cloud Assisted Records and Operations
 * Copyright (C) 2023-2024 error on line 1 (dev@erroronline.one)
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

// calendar
class CALENDARUTILITY {
	/**
	 * calendar handler writing to database and rendering either weeks or months for given date or now by default
	 * include to display calendar or use for scheduling and timesheets
	 * with hopefully well prepared date-handling
	 * 
	 * to avoid long parameter lists larger requiries will have to be passed as named arrays. this way calling scripts are supposed to be clearer.
	 * for transparency reasons these have to be well prepared as there is no default checking, thus may end in sql errors on purpose.
	 */

   	/**
	 * preset database connection, passed from main application
	 */
	private $_pdo = null;

   	/**
	 * displayed days for given date or default now, can be set through function days() and processed later on
	 * will be generated by function render() if not set or latter has been passed a date 
	 */
	public $_days = [];

	/**
	 * ini settings avoiding repetitive calls
	 */
	private $_holidays = [];
	private $_easter_holidays = [];
	public $_workdays = [];

	public function __construct($pdo){
		$this->_pdo = $pdo;
		$this->_holidays = preg_split('/[^\d-]+/', INI['calendar']['holidays']);
		$this->_easter_holidays = INI['calendar']['easter_holidays'];
		$this->_workdays = preg_split('/[^\d-]+/', INI['calendar']['workdays']);
	}

	/**
	 *       _         _
	 *   ___| |___ ___| |_
	 *  | .'| | -_|  _|  _|
	 *  |__,|_|___|_| |_|
	 *
	 * @return array sql result
	 */
	public function alert(){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_alert');
	}
	
	/**
	 *                     _     _
	 *   ___ ___ _____ ___| |___| |_ ___
	 *  |  _| . |     | . | | -_|  _| -_|
	 *  |___|___|_|_|_|  _|_|___|_| |___|
	 *                |_|
	 * @param str $id eventually comma separated multiple ints
	 * @param any $close boolval false will clear
	 * @param any $alert null remains state, bool updates
	 * @return int affected rows
	 */
	public function complete($id = '0', $close = null, $alert = null){
		$date = new DateTime('now', new DateTimeZone(INI['application']['timezone']));
		if ($close) $close = ['user' => $_SESSION['user']['name'], 'date' => $date->format('Y-m-d')];
		$sqlchunks = [];
		$affected_rows = 0;
		$entries = SQLQUERY::EXECUTE($this->_pdo, 'calendar_get_by_id', [
			'replacements' => [
				':id' => $id
			]
		]);
		foreach ($entries as $entry){
			$sqlchunks = SQLQUERY::CHUNKIFY($sqlchunks, strtr(SQLQUERY::PREPARE('calendar_complete'),
				[
					':id' => $this->_pdo->quote($entry['id']),
					':closed' => $this->_pdo->quote($close ? json_encode($close) : ''),
					':alert' => $alert === null ? $entry['alert'] : intval($alert)
				]
			));
		}
		foreach ($sqlchunks as $chunk){
			try {
				$rows = SQLQUERY::EXECUTE($this->_pdo, $chunk);
				if ($rows) $affected_rows += $rows;
			}
			catch (Exception $e) {
				echo $e, $chunk;
				die();
			}
		}
		return $affected_rows;
	}
	
	/**
	 *     _
	 *   _| |___ _ _ ___
	 *  | . | .'| | |_ -|
	 *  |___|__,|_  |___|
	 *          |___|
	 * calculates a calendar view, for given date week starts on monday, month on 1st
	 * 
	 * @param string $format month|week
	 * @param string $date yyyy-mm-dd
	 */
	public function days($format = '', $date = ''){
		$result = [];
		$date = new DateTime($date ? : 'now', new DateTimeZone(INI['application']['timezone']));
		$date->setTime(0, 0);
		if ($format === 'week') {
			$date->modify('- ' . ($date->format('N') - 1) . ' days');
			while ($date->format('N') < 7){
				$result[] = clone $date;
				$date->modify('+1 days');
			}
			$result[] = $date;
		}
		elseif ($format === 'month') {
			$date->modify('first day of this month');
			if ($date->format('N') > 1){
				for ($i = 1; $i < $date->format('N'); $i++){
					$result[] = null;
				}
			}
			while ($date->format('j') < $date->format('t')) {
				$result[] = clone $date;
				$date->modify('+1 days');
			}
			$result[] = $date;
		}
		// ensure the last day lasts to midnight for time comparisons
		$last_day = clone $result[count($result) - 1];
		$last_day->modify('+23 hours')->modify('+59 seconds');
		$result[count($result) - 1] = $last_day;
		$this->_days = $result;
	}
	
	/**
	 *     _     _     _
	 *   _| |___| |___| |_ ___
	 *  | . | -_| | -_|  _| -_|
	 *  |___|___|_|___|_| |___|
	 *
	 * @param int $id
	 * @return int affected rows
	 */
	public function delete($id = 0){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_delete', [
			'values' => [
				':id' => $id
			]
		]);
	}
	
	/**
	 *     _ _     _
	 *   _| |_|___| |___ ___
	 *  | . | | .'| | . | . |
	 *  |___|_|__,|_|___|_  |
	 *                  |___|
	 * returns an assemble.js dialog script to contribute to the calendar
	 * 
	 * @param array $columns, like put-method, but :type must be provided
	 * 	[
	 * 	':id' => int
	 * 	':type' => string schedule|timesheet
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int,
	 * 	':organizational_unit' => str,
	 * 	':subject' => str,
	 * 	':misc' => str (e.g. json_encoded whatnot),
	 * 	':closed' => str (e.g. json_encoded when, by whom),
	 * 	':alert' => int 1|0
	 * 	]
	 * @return string dialog script
	 */
	public function dialog($columns = []){
		if (!array_key_exists(':type', $columns)) return;
		// fill up default values
		foreach([':span_start', ':span_end', ':organizational_unit', ':subject', ':misc', 'closed'] as $str) if (!array_key_exists($str, $columns)) $columns[$str] = '';
		foreach([':id', ':alert'] as $int) if (!array_key_exists($int, $columns)) $columns[$int] = 0;
		foreach([':author_id', ':affected_user_id'] as $user) if (!array_key_exists($user, $columns)) $columns[$user] = $_SESSION['user']['id'];

		// prepare lists and datetime types for modification 
		$units = [];
		foreach(LANGUAGEFILE['units'] as $unit => $description){
			$units[$description] = (in_array($unit, explode(',', $columns[':organizational_unit'])) || (!$columns[':organizational_unit'] && array_key_exists('primaryUnit', $_SESSION['user']['app_settings']) && $unit === $_SESSION['user']['app_settings']['primaryUnit'])) ? ['checked' => true, 'value' => 'unit'] : ['value' => 'unit'];
		}

		$affected_users = $affected_unit_users = [];
		$users = SQLQUERY::EXECUTE($this->_pdo, 'user_get_datalist');
		// unset system user
		array_splice($users, array_search(1, array_column($users, 'id')), 1);
		// set self to top 
		$self = array_splice($users, array_search($_SESSION['user']['id'], array_column($users, 'id')), 1);
		array_splice($users, 0, 0, $self);
		foreach($users as $user){
			$affected_users[$user['name']] = ($columns[':affected_user_id'] === $user['id']) ? ['value' => $user['id'], 'selected' => true] : ['value' => $user['id']];
			if (array_intersect(explode(',', $user['units']), $_SESSION['user']['units'])) $affected_users[$user['name']] = ($columns[':affected_user_id'] === $user['id']) ? ['value' => $user['id'], 'selected' => true] : ['value' => $user['id']];
		}

		$alert = $span_start = $span_end = null; 
		$alert = [LANG::GET('calendar.event_alert') => $columns[':alert'] ? ['checked' => true] : []];
		
		if ($columns[':span_start']) $span_start = new DateTime($columns[':span_start'], new DateTimeZone(INI['application']['timezone']));
		else $span_start = new DateTime('now', new DateTimeZone(INI['application']['timezone']));

		switch ($columns[':type']){
			case 'schedule':
				if ($columns[':span_end']) $span_end = new DateTime($columns[':span_end'], new DateTimeZone(INI['application']['timezone']));
				else {
					$span_end = clone $span_start;
					$span_end->modify('+' . INI['calendar']['default_due'] . ' days');
				}
				$inputs = [
					[
						'type' => 'scanner',
						'attributes' => [
							'name' => LANG::GET('calendar.event_content'),
							'value' => $columns[':subject'],
							'required' => true
						]
					],
					[
						'type' => 'date',
						'attributes' => [
							'name' => LANG::GET('calendar.event_date'),
							'value' => $span_start->format('Y-m-d'),
							'required' => true
						]
					],
					[
						'type' => 'date',
						'attributes' => [
							'name' => LANG::GET('calendar.event_due'),
							'value' => $span_end->format('Y-m-d'),
							'required' => true
						]
					],
					[
						'type' => 'checkbox',
						'description' => LANG::GET('calendar.event_organizational_unit'),
						'content' => $units,
						'hint' => LANG::GET('calendar.event_organizational_unit_hint')
					],
					[
						'type' => 'checkbox',
						'description' => LANG::GET('calendar.event_alert_description'),
						'content' => $alert
					],
					[
						'type' => 'hidden',
						'attributes' => [
							'name' => LANG::GET('calendar.event_type'),
							'value' => $columns[':type']
						]
					],
					[
						'type' => 'hidden',
						'attributes' => [
							'name' => 'calendarEventId',
							'value' => $columns[':id'],		
						]
					]
				];
				break;
			case 'timesheet':
				if ($columns[':span_end']) $span_end = new DateTime($columns[':span_end'], new DateTimeZone(INI['application']['timezone']));
				else {
					$span_end = clone $span_start;
					$span_end->modify('+1 hour');
				}
		
				$misc = $columns[':misc'] ? json_decode($columns[':misc'], true) : [];
				
				$ptoselect = [];
				foreach(LANGUAGEFILE['calendar']['timesheet_pto'] as $subject => $reason){
					$ptoselect[$reason] = ['value' => $subject];
					if ($columns[':subject'] === $subject) $ptoselect[$reason]['selected'] = true;
				}

				$inputs = [];

				if (array_intersect(preg_split('/\W+/', INI['permissions']['calendaraddforeigntimesheet']), $_SESSION['user']['permissions'])){
					$inputs[] = [
						'type' => 'select',
						'content' => $affected_users,
						'attributes' => [
							'name' => LANG::GET('calendar.event_affected_user')
						]
					];
				} elseif (array_intersect(['supervisor'], $_SESSION['user']['permissions']) && array_intersect(explode(',', $row['affected_user_units']), $_SESSION['user']['units'])){
					$inputs[] = [
						'type' => 'select',
						'content' => $affected_unit_users,
						'attributes' => [
							'name' => LANG::GET('calendar.event_affected_user')
						]
					];
				} else {
					$inputs[] = [
						'type' => 'hidden',
						'attributes' => [
							'name' => LANG::GET('calendar.event_affected_user'),
							'value' => $columns[':affected_user_id']
						]
					];
				}
				// name => required bool
				$setFieldVisibility = [
					LANG::GET('calendar.timesheet_start_time') => true,
					LANG::GET('calendar.timesheet_end_time') => true,
					LANG::GET('calendar.timesheet_break_time') => true,
					LANG::GET('calendar.timesheet_homeoffice') => true
				];
				array_push($inputs, ...[
					[
						'type' => 'select',
						'attributes' => [
							'name' => LANG::GET('calendar.timesheet_pto_exemption'),
							'onchange' => "_client.calendar.setFieldVisibilityByNames('" . json_encode($setFieldVisibility) . "', this.value === LANG.GET('calendar.timesheet_pto.regular'))"
						],
						'content' => $ptoselect
					],[
						'type' => 'date',
						'attributes' => [
							'name' => LANG::GET('calendar.timesheet_start_date'),
							'value' => $span_start->format('Y-m-d'),
							'required' => true
						]
					],[
						'type' => 'time',
						'attributes' => [
							'name' => LANG::GET('calendar.timesheet_start_time'),
							'value' => $span_start->format('H:i'),
							'required' => true
						]
					],[
						'type' => 'date',
						'attributes' => [
							'name' => LANG::GET('calendar.timesheet_end_date'),
							'value' => $span_end->format('Y-m-d'),
							'required' => true
						]
						],[
							'type' => 'time',
							'attributes' => [
								'name' => LANG::GET('calendar.timesheet_end_time'),
								'value' => $span_end->format('H:i'),
								'required' => true
							]
						],[
							'type' => 'time',
							'attributes' => [
								'name' => LANG::GET('calendar.timesheet_break_time'),
								'value' => array_key_exists('break', $misc) ? $misc['break'] : '',
								'required' => true
							]
						],[
							'type' => 'text',
							'attributes' => [
								'name' => LANG::GET('calendar.timesheet_pto_note'),
								'value' => array_key_exists('note', $misc) ? $misc['note'] : '',
							]
						],[
							'type' => 'checkbox',
							'description' => LANG::GET('calendar.event_alert_description'),
							'content' => $alert
						],[
							'type' => 'hidden',
							'attributes' => [
								'name' => 'calendarEventId',
								'value' => $columns[':id']
							]
						]
					]);
				if (array_key_exists('homeoffice', $_SESSION['user']['app_settings']) && $_SESSION['user']['app_settings']['homeoffice'])
					array_splice($inputs, 7, 0, [
						[
							'type' => 'time',
							'attributes' => [
								'name' => LANG::GET('calendar.timesheet_homeoffice'),
								'value' => array_key_exists('homeoffice', $misc) ? $misc['homeoffice'] : '',
								'required' => true
							]
						]
					]);
				break;
		}

		return "new Dialog({type:'input', header: '', render: " . json_encode($inputs) . ", options:{'" . LANG::GET('calendar.event_cancel') . "': false, '" . LANG::GET('calendar.event_submit') . "': {'value': true, class: 'reducedCTA'}}})" .
			".then(response => {if (response) {_client.calendar.createFormData(response); api.calendar('" . ($columns[':id'] ? 'put': 'post') . "', '" . $columns[':type'] . "');}})";
	}
	
	/**
	 *           _     _
	 *   ___ ___| |_ _| |___ _ _
	 *  | . | -_|  _| . | .'| | |
	 *  |_  |___|_| |___|__,|_  |
	 *  |___|               |___|
	 * get all events where passed date is within span_start and span_end
	 * this results in all currently happening events
	 * 
	 * @param string $date Y-m-d
	 * @return array sql result
	 */
	public function getDay($date = ''){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_get_day', [
			'values' => [
				':date' => $date
			]
		]);
	}
	
	/**
	 *           _         _ _   _   _       _     _
	 *   ___ ___| |_ _ _ _|_| |_| |_|_|___ _| |___| |_ ___ ___ ___ ___ ___ ___
	 *  | . | -_|  _| | | | |  _|   | |   | . | .'|  _| -_|  _| .'|   | . | -_|
	 *  |_  |___|_| |_____|_|_| |_|_|_|_|_|___|__,|_| |___|_| |__,|_|_|_  |___|
	 *  |___|                                                         |___|
	 * get all events where span_start or span_end are within passed timespan 
	 * 
	 * @param string $earlier Y-m-d | null
	 * @param string $later Y-m-d | null
	 * @return array sql result
	 */
	public function getWithinDateRange($earlier = '', $later = ''){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_get_within_date_range', [
			'values' => [
				':earlier' => $earlier ? : '1970-01-01 00:00:01',
				':later' => $later ? : '2079-06-06 23:59:59'	
			]
		]);
	}
	
	/**
	 *   _       _ _   _
	 *  | |_ ___| |_|_| |___ _ _ ___
	 *  |   | . | | | . | .'| | |_ -|
	 *  |_|_|___|_|_|___|__,|_  |___|
	 *                      |___|
	 * calculates holidays for given year, according to setup.ini
	 * no setting up on construction for possible year overlaps on week rendering
	 * @param int $year Y
	 * @return array containing holiday dates for a given year
	 */
	public function holidays($year){
		$holidays = $this->_holidays;
		$holidays = array_map(Fn($d) => $year . '-'. $d, $holidays);

		$easter = new DateTime('now', new DateTimeZone(INI['application']['timezone']));
		$easter->setTimestamp(easter_date($year));
		foreach($this->_easter_holidays as $day => $offset){
			$easterholiday = clone $easter;
			$easterholiday->modify(($offset < 0 ? '-' : '+') . $offset .' days');
			$holidays[] = $easterholiday->format('Y-m-d');
		}
		return $holidays;
	}

	/**
	 *                 _               ___               _     _
	 *   ___ _ _ _____| |_ ___ ___ ___|  _|_ _ _ ___ ___| |_ _| |___ _ _ ___
	 *  |   | | |     | . | -_|  _| . |  _| | | | . |  _| '_| . | .'| | |_ -|
	 *  |_|_|___|_|_|_|___|___|_| |___|_| |_____|___|_| |_,_|___|__,|_  |___|
	 *                                                              |___|
	 * @param datetime $start
	 * @param datetime $end
	 * 
	 * @return int number of non-working days within timespan
	 */
	private function numberOfNonWorkdays($start, $end){
		$start = clone $start; // not passed by value but by reference
		$end = clone $end; // not passed by value but by reference
		// subtract holidays and weekends
		$holiday_num = 0;
		$holidays = $this->holidays($start->format('Y'));
		while ($start < $end){
			$year = $start->format('Y');
			if (in_array($start->format('Y-m-d'), $holidays) || !in_array($start->format('N'), $this->_workdays)) $holiday_num++;
			$start->modify('+1 day');
			if ($year !== $start->format('Y')) $holidays = $this->holidays($start->format('Y'));
		}
		return $holiday_num;
	}

	/**
	 *               _
	 *   ___ ___ ___| |_
	 *  | . | . |_ -|  _|
	 *  |  _|___|___|_|
	 *  |_|
	 * @param array $columns
	 * 	[
	 * 	':type' => string,
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int,
	 * 	':organizational_unit' => str,
	 * 	':subject' => str,
	 * 	':misc' => str (e.g. json_encoded whatnot),
	 * 	':closed' => str (e.g. json_encoded when, by whom),
	 * 	':alert' => int 1|0
	 * 	]
	 * @return int|bool insert id
	 */
	public function post($columns = []){
		if (SQLQUERY::EXECUTE($this->_pdo, 'calendar_post', [
			'values' => $columns
		])) return $this->_pdo->lastInsertId();
		return false;
	}
	
	/**
	 *           _
	 *   ___ _ _| |_
	 *  | . | | |  _|
	 *  |  _|___|_|
	 *  |_|
	 * @param array $columns
	 * 	[
	 * 	':id' => int
	 * 	type isn't supposed to change
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int,
	 * 	':organizational_unit' => str,
	 * 	':subject' => str,
	 * 	':misc' => str (e.g. json_encoded whatnot),
	 * 	':closed' => str (e.g. json_encoded when, by whom),
	 * 	':alert' => int 1|0
	 * 	]
	 * @return int affected rows
	 */
	public function put($columns = []){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_put', [
			'values' => $columns
		]);
	}

	/**
	 *                 _
	 *   ___ ___ ___ _| |___ ___
	 *  |  _| -_|   | . | -_|  _|
	 *  |_| |___|_|_|___|___|_|
	 *
	 * renders a calendar view, for given date week starts on monday, month on 1st, weekday offsets are empty
	 * calculates holidays for every date for possible year overlaps in selected view-format
	 * 
	 * @param string $format month|week
	 * @param string $type schedule|timesheet
	 * @param string $date yyyy-mm-dd
	 * 
	 * @return array assemble.js calendar type
	 */
	public function render($format = '', $type = '', $date = '', ){
		$result = ['header' => null, 'content' => []];
		if (!$this->_days || $date) $this->days($format, $date);

		$today = new DateTime('now', new DateTimeZone(INI['application']['timezone']));
		foreach ($this->_days as $day){
			if ($day === null) $result['content'][] = null;
			else {
				$events = $this->getDay($day->format('Y-m-d'));
				$numbers = 0;
				foreach ($events as $row){
					switch ($type){
						case 'schedule':
							if ($row['type'] === $type && array_intersect(explode(',', $row['organizational_unit']), $_SESSION['user']['units']))
								if (!$row['closed'])
								$numbers++;
							break;
						case 'timesheet':
							if ($row['type'] === $type && array_intersect(explode(',', $row['affected_user_units']), $_SESSION['user']['units']))
							$numbers++;
					}	
				}
				$result['content'][] = [
					'date' => $day->format('Y-m-d'),
					'display' => LANGUAGEFILE['general']['weekday'][$day->format('N')] . ' ' . $day->format('j') . ($numbers ? "\n" . $numbers : ''),
					'today' => $day->format('Y-m-d') === $today->format('Y-m-d'),
					'selected' => $date === $day->format('Y-m-d'),
					'holiday' => in_array($day->format('Y-m-d'), $this->holidays($day->format('Y'))) || !in_array($day->format('N'), $this->_workdays)
				];
				if ($result['header']) continue;
				if ($format === 'week') $result['header'] = LANG::GET('general.calendar_week', [':number' => $day->format('W')]) . ' ' . $day->format('Y');
				if ($format === 'month') $result['header'] = LANGUAGEFILE['general']['month'][$day->format('n')] . ' ' . $day->format('Y');
			}
		}
		return $result;
	}

	/**
	 *   _   _               _           _
	 *  | |_|_|_____ ___ ___| |_ ___ ___| |_ ___ _ _ _____ _____ ___ ___ _ _
	 *  |  _| |     | -_|_ -|   | -_| -_|  _|_ -| | |     |     | .'|  _| | |
	 *  |_| |_|_|_|_|___|___|_|_|___|___|_| |___|___|_|_|_|_|_|_|__,|_| |_  |
	 *                                                                  |___|
	 * calculates time and off-duty days summed up for users from beginning of a given month to the end of another given month
	 * overtime and vacation calculation only works if $from_date starts from the dawn of time
	 * so you might have to do two queries and combine their output,
	 * e.g. leftvacation and alltime overtime have to be calculated for the whole database timespan,
	 * pto might make sense for a given month only
	 * 
	 * @param array $users array of users with columns
	 * @param object|string $from_date DateTime|Y-m-d
	 * @param object|string $to_date DateTime|Y-m-d
	 * 
	 * @return array
	 * 	[
	 * 		[
	 *			'_id' => int,
	 *			'_name' => string,
	 *			'_units' => string,
	 *			'_weeklyhours' => array with start datetime and value,
	 *			'_span_end_weeklyhours' => int, // last applied due to given timespan
	 *			'_annualvacation' => array with start datetime and value,
	 *			'_leftvacation' => int,
	 *			'_projected' => float,
	 *			'_performed' => float,
	 *			'_overtime' => float,
	 *			'_pto' => array with datetime and value
	 *			...
	 * 			any pto days will be counted by their respective languagefile key as int
	 * 		],
	 * 		...
	 * 	]
	 */
	public function timesheetSummary($users = [], $from_date = '', $to_date = ''){
		$datetimezone = new DateTimeZone(INI['application']['timezone']);
		$minuteInterval = new DateInterval('PT1M');
		$from_date = gettype($from_date) === 'object' ? $from_date : new DateTime($from_date ? : '1970-01-01', $datetimezone);
		$from_date->modify('first day of this month')->setTime(0, 0);
		$to_date = gettype($to_date) === 'object' ? $to_date : new DateTime($to_date ? : 'now', $datetimezone);
		$to_date->modify('last day of this month')->setTime(23, 59, 59);
		$entries = $this->getWithinDateRange($from_date->format('Y-m-d H:i:s'), $to_date->format('Y-m-d H:i:s'));
		$result = [];
		// sort result span_start to process user-settings in the right order
		array_multisort(array_column($entries, 'span_start'), SORT_ASC, $entries);
		
		// prepare all users eligible for timetracking due to average weekly hours set
		foreach ($users as $row => $user){
			$user['app_settings'] = $users[$row]['app_settings'] = json_decode($user['app_settings'] ? : '', true);
			if (!$user['app_settings'] || !array_key_exists('weeklyhours', $user['app_settings']) || !$user['app_settings']['weeklyhours']){
				unset ($users[$row]);
				continue;
			}
			// prepare timesheet settings, use _ to avoid overwriting from dynamically prepared keys
			$users[$row]['timesheet'] = [
				'_id' => $user['id'],
				'_weeklyhours' => [],
				'_span_end_weeklyhours' => null, // last applied due to given timespan
				'_annualvacation' => [],
				'_leftvacation' => 0,
				'_projected' => 0,
				'_performed' => 0,
				'_overtime' => array_key_exists('initialovertime', $user['app_settings']) ? floatval(str_replace(',', '.', $user['app_settings']['initialovertime'])) : 0,
				'_pto' => []
			];
			// prepare occasionally changing contract settings
			// create array with start date of changes and applicable value
			foreach(['weeklyhours', 'annualvacation'] as $setting){
				$hours_vacation = [];
				if (array_key_exists($setting, $user['app_settings'])){
					$settingentries = explode(';', $user['app_settings'][$setting]);
					natsort($settingentries);
					foreach($settingentries as $line){
						preg_match('/(\d{4}\-\d{2}\-\d{2}).+?([\d,\.]+)/', $line, $lineentry);
						$hours_vacation[] = ['date' => new DateTime($lineentry[1], $datetimezone), 'value' => floatval(str_replace(',', '.', $lineentry[2]))];
					}
				} else $hours_vacation[] = ['date' => new DateTime('1970-01-01', $datetimezone), 'value' => 0];
				array_multisort(array_column($hours_vacation, 'date'), SORT_ASC, $hours_vacation);
				$users[$row]['timesheet']['_' . $setting] = $hours_vacation;
			}
		}
		$users = array_values($users); // reindex

		// process actual entries and contribute to user timesheet array
		foreach ($entries as $entry){
			if ($entry['type'] !== 'timesheet' || !in_array($entry['affected_user_id'], array_column($users, 'id'))) continue;
			$row = array_search($entry['affected_user_id'], array_column($users, 'id'));
			$user = $users[$row];

			// convert to datetime, limit to month boundaries if necessary
			$span_start = new DateTime($entry['span_start'], $datetimezone);
			if ($span_start < $from_date) $span_start = clone $from_date;
			$span_end = new DateTime($entry['span_end'], $datetimezone);
			if ($span_end > $to_date) $span_end = clone $to_date;

			// get breaks and homeoffice times
			$misc = json_decode($entry['misc'], true);

			if (!strlen($entry['subject'])) { // aka regular working day
				if ($span_start < $user['timesheet']['_weeklyhours'][0]['date']){
					// since entries are sorted by date, if dated earlier than the initial applied weeklyhours this can not be applicable
					continue;
				}
				// calculate and add hours
				$periods = new DatePeriod($span_start, $minuteInterval, $span_end);
				$hours = iterator_count($periods) / 60;
				if (array_key_exists('homeoffice', $misc)) $hours += $this->timeStrToFloat($misc['homeoffice']);
				if (array_key_exists('break', $misc)) $hours -= $this->timeStrToFloat($misc['break']);
				$users[$row]['timesheet']['_performed'] += $hours;
			} else {
				// count off duty days
				$span_start->setTime(0, 0);
				$span_end->setTime(23, 59, 59);

				if (!$user['timesheet']['_annualvacation'] || $span_start < $user['timesheet']['_annualvacation'][0]['date']){
					// if setting is empty vacations are obviously not used by this user
					// since entries are sorted by date, if dated earlier than the last applied annualvacation this can not be applicable
					continue;
				}
				$days = intval($span_start->diff($span_end)->format('%a')) + 1;

				if (!array_key_exists($entry['subject'], $users[$row]['timesheet'])) $users[$row]['timesheet'][$entry['subject']] = 0;
				$days -= $this->numberOfNonWorkdays($span_start, $span_end);
				$users[$row]['timesheet'][$entry['subject']] += $days;

				// add eligible pto to a dated array for below use
				if ($entry['subject'] !== 'timeoff') $users[$row]['timesheet']['_pto'][] = ['start' => $span_start, 'end' => $span_end, 'value' => $days];
			}
		}
		/** reiterate over users
		 * gather all projected working hours and set overtime += performed - projected
		 * gather all annual vacations and set leftvacation += allvacations - vacation
		 * outside of database for possibility of not having submitted entries
		 */
		foreach ($users as $row => $user){
			// accumulate projected hours for given timespan according to applicable contract settings at the respective time
			for($i = 0; $i < count($user['timesheet']['_weeklyhours']); $i++){
				$startdate = $user['timesheet']['_weeklyhours'][$i]['date'];
				if ($startdate > $to_date) break;
				if ($i === count($user['timesheet']['_weeklyhours']) - 1) $enddate = clone $to_date;
				else {
					$enddate = clone $user['timesheet']['_weeklyhours'][$i + 1]['date'];
					$enddate->modify('-1 day');
				}
				if ($enddate < $from_date) continue;
				if ($startdate < $from_date) $startdate = clone $from_date;

				$users[$row]['timesheet']['_span_end_weeklyhours'] = $user['timesheet']['_weeklyhours'][$i]['value'];
				$daynum = intval($startdate->diff($enddate)->format('%a')) + 1;
				$holidays = $this->numberOfNonWorkdays($startdate, $enddate);
				// add reasonable pto to holidays, that are not expected to contribute to projected
				foreach($user['timesheet']['_pto'] as $pto){
					$ptostart = $pto['start'];
					$ptoend = $pto['end'];
					if ($ptostart >= $startdate && $ptoend <= $enddate) {
						$holidays += $pto['value'];
						continue;
					}
					if ($ptostart > $enddate || $ptoend < $startdate) continue;
					if ($ptostart < $startdate) $ptostart = $startdate;
					if ($ptoend > $enddate) $ptoend = $enddate;
					$ptonum = intval($ptostart->diff($ptoend)->format('%a')) + 1;
					if ($ptonum) $holidays += $pto['value'] - $ptonum;
				}
				$users[$row]['timesheet']['_projected'] += ($daynum - $holidays) * ($user['timesheet']['_weeklyhours'][$i]['value'] / count($this->_workdays));
			}
			$users[$row]['timesheet']['_overtime'] += $users[$row]['timesheet']['_performed'] - $users[$row]['timesheet']['_projected'];

			// accumulate annual vacation days always from the beginning of tracking according to applicable contract settings at the respective time
			$users[$row]['timesheet']['_leftvacation'] = $user['timesheet']['_annualvacation'][0]['value'];
			for($i = 1; $i < count($user['timesheet']['_annualvacation']); $i++){
				$startdate = $user['timesheet']['_annualvacation'][$i]['date'];
				if ($startdate > $to_date) break;
				$enddate = ($i === count($user['timesheet']['_annualvacation']) - 1) ? $to_date : $user['timesheet']['_annualvacation'][$i + 1]['date'];
				$annualstart = clone $startdate;
				$year = '';
				while ($annualstart < $enddate){
					if ($annualstart->format('Y') != $year){
						$users[$row]['timesheet']['_leftvacation'] += $user['timesheet']['_annualvacation'][$i]['value'];
						$year = $annualstart->format('Y');
					}
					$annualstart->modify('+1 month');
				}
			}
			if (array_key_exists('vacation', $user['timesheet'])) $users[$row]['timesheet']['_leftvacation'] -= $users[$row]['timesheet']['vacation'];
			$result[] = $users[$row]['timesheet'];
		}
		return $result;
	}

	/**
	 *   _   _               _       _       ___ _         _
	 *  | |_|_|_____ ___ ___| |_ ___| |_ ___|  _| |___ ___| |_
	 *  |  _| |     | -_|_ -|  _|  _|  _| . |  _| | . | .'|  _|
	 *  |_| |_|_|_|_|___|___|_| |_| |_| |___|_| |_|___|__,|_|
	 *
	 * returns a float from H:i format
	 * 
	 * @param string $string H:i
	 * 
	 * @return float
	 */
	public function timeStrToFloat($string){
		$string = explode(':', $string);
		return intval($string[0]) + (intval($string[1]) / 60);
	}

	/**
	 *                       _
	 *   ___ ___ ___ ___ ___| |_
	 *  |_ -| -_| .'|  _|  _|   |
	 *  |___|___|__,|_| |___|_|_|
	 *
	 * @param string $search
	 * @return array sql result
	 */
	public function search($search = ''){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_search', [
			'values' => [
				':subject' => $search
			]
		]);
	}
}
?>