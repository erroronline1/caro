<?php
/**
 * CARO - Cloud Assisted Records and Operations
 * Copyright (C) 2023-2025 error on line 1 (dev@erroronline.one)
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

namespace CARO\API;

// calendar
class CALENDARUTILITY {
	/**
	 * calendar handler writing to database and rendering either weeks or months for given date or now by default
	 * include to display calendar or use for scheduling and timesheets
	 * with hopefully well prepared date-handling
	 * 
	 * to avoid long parameter lists larger requiries will have to be passed as named arrays. this way calling scripts are supposed to be clearer.
	 * for transparency reasons these have to be well prepared as there is no default checking, thus may end in sql errors on purpose.
	 */

   	/**
	 * preset database connection, passed from main application
	 */
	private $_pdo = null;

	/**
	 * preset date settings, passed from main application by probably updated by user settings
	 */
	public $_date = [];

   	/**
	 * displayed days for given date or default now, can be set through function days() and processed later on
	 * will be generated by function render() if not set or latter has been passed a date 
	 */
	public $_days = [];

	/**
	 * make languagemodel LANG class and its methods available
	 */
	public $_lang = null;

	/**
	 * ini settings avoiding repetitive calls
	 */
	private $_holidays = [];
	private $_easter_holidays = [];
	public $_workdays = [];
	private $_breaks = [];

	public function __construct($pdo, $date){
		$this->_pdo = $pdo;
		$this->_lang = new LANG();
		$this->_date = $date;

		$this->_holidays = array_filter(preg_split('/[^\d-]+/', $this->_date['locations']['holidays']), fn($v) => boolval($v)); // mm-dd, mm-dd, ...
		$this->_easter_holidays = array_filter(preg_split('/[^\d-]+/', $this->_date['locations']['easter']), fn($v) => boolval($v)); // offsets from easter sunday
		$this->_workdays = array_filter(preg_split('/[^\d-]+/', $this->_date['locations']['workdays']), fn($v) => boolval($v)); // 1-7 starting on monday
		$this->_breaks = array_filter(preg_split('/[^\d-]+/', $this->_date['locations']['breaks']), fn($v) => boolval($v)); // hours-minbreak
	}

	/**
	 *       _         _
	 *   ___| |___ ___| |_
	 *  | .'| | -_|  _|  _|
	 *  |__,|_|___|_| |_|
	 *
	 * @return array sql result
	 */
	public function alert(){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_alert');
	}
	
	/**
	 *                     _     _
	 *   ___ ___ _____ ___| |___| |_ ___
	 *  |  _| . |     | . | | -_|  _| -_|
	 *  |___|___|_|_|_|  _|_|___|_| |___|
	 *                |_|
	 * @param str $id eventually comma separated multiple ints
	 * @param any $close boolval false will clear
	 * @param any $alert null remains state, bool updates
	 * @return int affected rows
	 */
	public function complete($id = '0', $close = null, $alert = null){
		if ($close) $close = ['user' => $_SESSION['user']['name'], 'date' => $this->_date['servertime']->format('Y-m-d')];
		$sqlchunks = [];
		$affected_rows = 0;
		$entries = SQLQUERY::EXECUTE($this->_pdo, 'calendar_get_by_id', [
			'replacements' => [
				':id' => $id
			]
		]);
		foreach ($entries as $entry){
			$sqlchunks = SQLQUERY::CHUNKIFY($sqlchunks, strtr(SQLQUERY::PREPARE('calendar_complete'),
				[
					':id' => $entry['id'],
					':closed' => $close ? $this->_pdo->quote(UTILITY::json_encode($close)) : 'NULL',
					':alert' => $alert === null ? $entry['alert'] : (intval($alert) ? 1 : 'NULL')
				]
			));
		}
		foreach ($sqlchunks as $chunk){
			try {
				$rows = SQLQUERY::EXECUTE($this->_pdo, $chunk);
				if ($rows) $affected_rows += $rows;
			}
			catch (\Exception $e) {
				echo $e, $chunk;
				die();
			}
		}
		return $affected_rows;
	}
	
	/**
	 *     _     _       ___                   _   
	 *   _| |___| |_ ___|  _|___ ___ _____ ___| |_ 
	 *  | . | .'|  _| -_|  _| . |  _|     | .'|  _|
	 *  |___|__,|_| |___|_| |___|_| |_|_|_|__,|_|  
	 *
	 * formats ISO 8601 date to custom as per config 
	 * @param string $input YYYY-MM-DD (time optional)
	 * @return string
	 */
	public function dateFormat($input){
		if (!$input) return '';
		if (!$this->_date['dateformat']) return $input;
		try {
			$date = new \DateTime(substr($input, 0, 10));
		}
		catch (\Exception $e) {
			return $input;
		}
		return $date->format($this->_date['dateformat']) . (strlen($input) > 10 ? substr($input, 10) : '');
	}
	
	/**
	 *     _
	 *   _| |___ _ _ ___
	 *  | . | .'| | |_ -|
	 *  |___|__,|_  |___|
	 *          |___|
	 * calculates datetime objects for a calendar view, for given date week starts on monday, month on 1st
	 * 
	 * @param string $format month|week
	 * @param string $date yyyy-mm-dd
	 */
	public function days($format = '', $date = ''){
		$result = [];
		$date = new \DateTime($date ? : 'now');
		$date->setTime(0, 0);

		// prepare dates for requested week
		if ($format === 'week') {
			$date->modify('- ' . ($date->format('N') - 1) . ' days');
			while ($date->format('N') < 7){
				$result[] = clone $date;
				$date->modify('+1 days');
			}
			$result[] = $date;
		}
		// prepare dates for requested month
		elseif ($format === 'month') {
			$date->modify('first day of this month');
			if ($date->format('N') > 1){
				for ($i = 1; $i < $date->format('N'); $i++){
					$result[] = null;
				}
			}
			while ($date->format('j') < $date->format('t')) {
				$result[] = clone $date;
				$date->modify('+1 days');
			}
			$result[] = $date;
		}

		// ensure the last day lasts to midnight for time comparisons
		$last_day = clone $result[count($result) - 1];
		$last_day->modify('+23 hours')->modify('+59 seconds');
		$result[count($result) - 1] = $last_day;
		$this->_days = $result;
	}
	
	/**
	 *     _     _     _
	 *   _| |___| |___| |_ ___
	 *  | . | -_| | -_|  _| -_|
	 *  |___|___|_|___|_| |___|
	 *
	 * @param int $id
	 * @return int affected rows
	 */
	public function delete($id = 0){
		if ($id !== null) return SQLQUERY::EXECUTE($this->_pdo, 'calendar_delete', [
			'values' => [
				':id' => $id
			]
		]);
		$num = 0;
		foreach ($this->getWithinDateRange() as $entry){
			if (!$entry['closed']) continue;
			$entry['closed'] = json_decode($entry['closed'], true);
			$closed = new \DateTime($entry['closed']['date']);
			if (intval(abs($closed->diff($this->_date['servertime'])->days > CONFIG['lifespan']['calendar']['autodelete'])) && SQLQUERY::EXECUTE($this->_pdo, 'calendar_delete', [
				'values' => [
					':id' => $entry['id']
				]
			])) $num++;
		}
		return $num;
	}
	
	/**
	 *     _ _     _
	 *   _| |_|___| |___ ___
	 *  | . | | .'| | . | . |
	 *  |___|_|__,|_|___|_  |
	 *                  |___|
	 * returns an assemble.js dialog script to contribute to the calendar
	 * 
	 * @param array $columns, like put-method, but :type must be provided
	 * 	[
	 * 	':id' => int
	 * 	':type' => string schedule|timesheet
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int | null,
	 * 	':organizational_unit' => str | null,
	 * 	':subject' => str | null,
	 * 	':misc' => str (e.g. UTILITY::json_encoded whatnot) | null,
	 * 	':closed' => str (e.g. UTILITY::json_encoded when, by whom) | null,
	 * 	':alert' => int 1 | null,
	 * 	':autodelete' => int 1 | null
	 * 	]
	 * @return string dialog script
	 */
	public function dialog($columns = []){
		if (!isset($columns[':type'])) return;

		// fill up default values
		foreach ([':span_start', ':span_end', ':organizational_unit', ':subject', ':misc', 'closed'] as $str) if (!isset($columns[$str])) $columns[$str] = '';
		foreach ([':id', ':alert', ':autodelete'] as $int) if (!isset($columns[$int])) $columns[$int] = 0;
		foreach ([':author_id'] as $user) if (!isset($columns[$user])) $columns[$user] = $_SESSION['user']['id'];
		$columns[':affected_user_id'] = isset($columns[':affected_user_id']) ? $columns[':affected_user_id'] : null; 

		// prepare lists and datetime types for modification 
		$units = [];
		foreach ($this->_lang->_USER['units'] as $unit => $description){
			$units[$description] = (in_array($unit, explode(',', $columns[':organizational_unit'])) || (!$columns[':organizational_unit'] && isset($_SESSION['user']['app_settings']['primaryUnit']) && $unit === $_SESSION['user']['app_settings']['primaryUnit'])) ? ['checked' => true, 'value' => 'unit'] : ['value' => 'unit'];
		}

		$affected_users = $affected_unit_users = ['...' => ['value' => '...']];
		$users = SQLQUERY::EXECUTE($this->_pdo, 'user_get_datalist');
		// set self to top 
		$self = array_splice($users, array_search($_SESSION['user']['id'], array_column($users, 'id')), 1);
		array_splice($users, 0, 0, $self);
		// construct list for affected user selection
		foreach ($users as $user){
			if ($user == $self || PERMISSION::filteredUser($user)) continue;
			if (in_array($columns[':type'], ['timesheet']) && PERMISSION::filteredUser($user, ['permission' => ['group']])) continue;
			
			$affected_users[$user['name']] = ($columns[':affected_user_id'] === $user['id']) ? ['value' => $user['id'], 'selected' => true] : ['value' => $user['id']];
			if (array_intersect(explode(',', $user['units']), $_SESSION['user']['units'])) $affected_unit_users[$user['name']] = ($columns[':affected_user_id'] === $user['id']) ? ['value' => $user['id'], 'selected' => true] : ['value' => $user['id']];
			if ($columns[':affected_user_id'] === $user['id'] && !$columns[':organizational_unit']) $columns[':organizational_unit'] = $user['units'];
		}

		// set up defaults
		$alert = $autodelete = $span_start = $span_end = null; 
		$alert = [$this->_lang->GET('calendar.schedule.alert') => $columns[':alert'] ? ['checked' => true] : []];		
		$autodelete = [$this->_lang->GET('calendar.schedule.autodelete', [':days' => CONFIG['lifespan']['calendar']['autodelete']]) => $columns[':id'] === 0 || $columns[':autodelete'] ? ['checked' => true] : []];		
		$span_start = new \DateTime($columns[':span_start'] ? : 'now');

		// assemble by type
		switch ($columns[':type']){
			case 'schedule':
				// set end date to preset of CONFIG default
				if ($columns[':span_end']) $span_end = new \DateTime($columns[':span_end']);
				else {
					$span_end = clone $span_start;
					$span_end->modify('+' . CONFIG['calendar']['default_due'] . ' days');
				}
				// add inputs
				$inputs = [
					[
						'type' => 'scanner',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.content'),
							'value' => $columns[':subject'],
							'required' => true
						]
					], [
						'type' => 'date',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.date'),
							'value' => $span_start->format('Y-m-d'),
							'required' => true
						]
					], [
						'type' => 'date',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.due'),
							'value' => $span_end->format('Y-m-d'),
							'required' => true
						]
					], [
						'type' => 'checkbox',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.organizational_unit')
						],
						'content' => $units,
						'hint' => $this->_lang->GET('calendar.schedule.organizational_unit_hint')
					], [
						'type' => 'select',
						'content' => $affected_users,
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.affected_user')
						]
					], [
						'type' => 'checkbox',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.options')
						],
						'content' => array_merge($alert, $autodelete)
					], [
						'type' => 'hidden',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.type'),
							'value' => $columns[':type']
						]
					], [
						'type' => 'hidden',
						'attributes' => [
							'name' => 'calendarEventId',
							'value' => $columns[':id'],		
						]
					]
				];
				break;
			case 'timesheet':
				// set end date to preset of CONFIG default
				if ($columns[':span_end']) $span_end = new \DateTime($columns[':span_end']);
				else {
					$span_end = clone $span_start;
					$span_end->modify('+1 hour');
				}
				
				// resolve encoded misc information
				$misc = $columns[':misc'] ? json_decode($columns[':misc'], true) : [];
				
				// construct available pto-reasons
				$ptoselect = [];
				foreach ($this->_lang->_USER['calendar']['timesheet']['pto'] as $subject => $reason){
					$ptoselect[$reason] = ['value' => $subject];
					if ($columns[':subject'] === $subject) $ptoselect[$reason]['selected'] = true;
				}

				$inputs = [];

				// conditional adding affected user
				if (array_intersect(preg_split('/\W+/', CONFIG['permissions']['calendaraddforeigntimesheet']), $_SESSION['user']['permissions'])){
					$inputs[] = [
						'type' => 'select',
						'content' => $affected_users,
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.affected_user'),
							'required' => true
						]
					];
				} elseif (array_intersect(['supervisor'], $_SESSION['user']['permissions']) && array_intersect(explode(',', $columns[':organizational_unit']), $_SESSION['user']['units'])){
					$inputs[] = [
						'type' => 'select',
						'content' => $affected_unit_users,
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.affected_user'),
							'required' => true
						]
					];
				} else {
					$inputs[] = [
						'type' => 'hidden',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.affected_user'),
							'value' => $columns[':affected_user_id']
						]
					];
				}
				// name => required bool, display bool as per _client.calendar.setFieldVisibilityByNames()
				$setFieldVisibility = [
					$this->_lang->GET('calendar.timesheet.start_time') => ['required' => true, 'display' => true],
					$this->_lang->GET('calendar.timesheet.end_time') => ['required' => true, 'display' => true],
					$this->_lang->GET('calendar.timesheet.break_time') => ['required' => true, 'display' => true],
					$this->_lang->GET('calendar.timesheet.homeoffice') => ['required' => true, 'display' => true],
					$this->_lang->GET('calendar.timesheet.workinghourscorrection') => ['required' => false, 'display' => true],
					$this->_lang->GET('calendar.schedule.alert') => ['required' => false, 'display' => false],
				];

				// break recommendation according to config
				$breakrecommendation = '';
				if(isset($this->_date['locations']['breaks'])){
					$breakrecommendation = "let start = document.getElementById('_starttime').value, end = this.value, time, breaktime = '00:00'; ".
						"start = parseInt(start) + parseInt(start.split(':')[1]) / 60; end = parseInt(end) + parseInt(end.split(':')[1]) / 60; ".
						"time = end - start; ";
					for ($i = 0; $i < count($this->_breaks); $i++){
						list(, $previousbreak) = isset($this->_breaks[$i-1]) ? explode('-', $this->_breaks[$i-1]): [0, 0];
						list($hours, $break) = explode('-', $this->_breaks[$i]);
						$hrs = strlen(intval($break / 60)) < 2 ? '0'. intval($break / 60) : intval($break / 60);
						$min = intval((floatval($break) / 60 - intval($break / 60)) * 60);
						$hrs = strlen($hrs) < 2 ? '0' . $hrs : $hrs;
						$min = strlen($min) < 2 ? '0' . $min : $min;
						$breakrecommendation .= "if (time - " . (floatval($previousbreak) / 60) . " > " . $hours . ") breaktime = '" . $hrs . ":" . $min . "'; ";
					}
					$breakrecommendation .= "if (breaktime) document.getElementById('_break').value = breaktime;";
				}
				// add inputs
				array_push($inputs, ...[
					[
						'type' => 'select',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.timesheet.pto_exemption'),
							'onchange' => "_client.calendar.setFieldVisibilityByNames('" . UTILITY::json_encode($setFieldVisibility) . "', this.value === 'regular')"
						],
						'content' => $ptoselect
					], [
						'type' => 'date',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.timesheet.start_date'),
							'value' => $span_start->format('Y-m-d'),
							'required' => true
						]
					], [
						'type' => 'time',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.timesheet.start_time'),
							'value' => $span_start->format('H:i'),
							'required' => true,
							'id' => '_starttime'
						]
					], [
						'type' => 'date',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.timesheet.end_date'),
							'value' => $span_end->format('Y-m-d'),
							'required' => true
						]
					], [
						'type' => 'time',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.timesheet.end_time'),
							'value' => $span_end->format('H:i'),
							'required' => true,
							'onchange' => $breakrecommendation
						]
					], [
						'type' => 'time',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.timesheet.break_time'),
							'value' => isset($misc['break']) ? $misc['break'] : '',
							'required' => true,
							'id' => '_break'
						]
					], [
						'type' => 'number',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.timesheet.workinghourscorrection'),
							'value' => isset($misc['workinghourscorrection']) ? $misc['workinghourscorrection'] : ''
						]
					], [
						'type' => 'text',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.timesheet.pto_note'),
							'value' => isset($misc['note']) ? $misc['note'] : '',
						]
					], [
						'type' => 'checkbox',
						'attributes' => [
							'name' => $this->_lang->GET('calendar.schedule.options')
						],
						'content' => $alert
					], [
						'type' => 'hidden',
						'attributes' => [
							'name' => 'calendarEventId',
							'value' => $columns[':id']
						]
					]
				]);
				// add homeoffice input if applicable
				if (isset($_SESSION['user']['app_settings']['homeoffice']) && $_SESSION['user']['app_settings']['homeoffice'])
					array_splice($inputs, 7, 0, [
						[
							'type' => 'time',
							'attributes' => [
								'name' => $this->_lang->GET('calendar.timesheet.homeoffice'),
								'value' => isset($misc['homeoffice']) ? $misc['homeoffice'] : '',
								'required' => true
							]
						]
					]);
				break;
		}

		return "new _client.Dialog({type:'input', header: '', render: " . UTILITY::json_encode($inputs) . ", options:{'" . $this->_lang->GET('calendar.schedule.cancel') . "': false, '" . $this->_lang->GET('calendar.schedule.submit') . "': {'value': true, class: 'reducedCTA'}}}, 'FormData')" .
			".then(response => {if (response) {api.calendar('" . ($columns[':id'] ? 'put': 'post') . "', '" . $columns[':type'] . "', response);}})";
	}
	
	/**
	 *           _     _
	 *   ___ ___| |_ _| |___ _ _
	 *  | . | -_|  _| . | .'| | |
	 *  |_  |___|_| |___|__,|_  |
	 *  |___|               |___|
	 * get all events where passed date is within span_start and span_end
	 * this results in all currently happening events
	 * 
	 * @param string $date Y-m-d
	 * @return array sql result
	 */
	public function getDay($date = ''){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_get_day', [
			'values' => [
				':date' => $date
			]
		]);
	}
	
	/**
	 *           _         _ _   _   _       _     _
	 *   ___ ___| |_ _ _ _|_| |_| |_|_|___ _| |___| |_ ___ ___ ___ ___ ___ ___
	 *  | . | -_|  _| | | | |  _|   | |   | . | .'|  _| -_|  _| .'|   | . | -_|
	 *  |_  |___|_| |_____|_|_| |_|_|_|_|_|___|__,|_| |___|_| |__,|_|_|_  |___|
	 *  |___|                                                         |___|
	 * get all events where span_start or span_end are within passed timespan 
	 * 
	 * @param string $earlier Y-m-d | null
	 * @param string $later Y-m-d | null
	 * @return array sql result
	 */
	public function getWithinDateRange($earlier = '', $later = ''){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_get_within_date_range', [
			'values' => [
				':earlier' => $earlier ? : '1970-01-01 00:00:01',
				':later' => $later ? : '2079-06-05 23:59:59'	
			]
		]);
	}
	
	/**
	 *   _       _ _   _
	 *  | |_ ___| |_|_| |___ _ _ ___
	 *  |   | . | | | . | .'| | |_ -|
	 *  |_|_|___|_|_|___|__,|_  |___|
	 *                      |___|
	 * calculates holidays for given year, according to CONFIG
	 * no setting up on construction for possible year overlaps on week rendering
	 * @param int $year Y
	 * @return array containing holiday dates for a given year
	 */
	public function holidays($year){
		// apply all public holidays
		$holidays = $this->_holidays;
		$holidays = array_map(Fn($d) => $year . '-'. $d, $holidays);

		// apply all holidays depended on easter sunday
		$easter = new \DateTime('now');
		$easter->setTimestamp(easter_date($year));
		foreach ($this->_easter_holidays as $offset){
			$easterholiday = clone $easter;
			$easterholiday->modify(($offset < 0 ? '-' : '+') . $offset .' days');
			$holidays[] = $easterholiday->format('Y-m-d');
		}
		return $holidays;
	}

	/**
	 *                 _               ___                           _     _             
	 *   ___ _ _ _____| |_ ___ ___ ___|  _|___ ___ ___ _ _ _ ___ ___| |_ _| |___ _ _ ___ 
	 *  |   | | |     | . | -_|  _| . |  _|   | . |   | | | | . |  _| '_| . | .'| | |_ -|
	 *  |_|_|___|_|_|_|___|___|_| |___|_| |_|_|___|_|_|_____|___|_| |_,_|___|__,|_  |___|
	 *                                                                          |___|
	 * @param datetime $start
	 * @param datetime $end
	 * 
	 * @return int number of non-working days within timespan including holidays and CONFIG unselected workdays
	 */
	private function numberOfNonWorkdays($start, $end){
		$start = clone $start; // not passed by value but by reference
		$end = clone $end; // not passed by value but by reference
		// subtract holidays and weekends
		$holiday_num = 0;
		$holidays = $this->holidays($start->format('Y'));
		while ($start < $end){
			$year = $start->format('Y');
			if (in_array($start->format('Y-m-d'), $holidays) || !in_array($start->format('N'), $this->_workdays)) $holiday_num++;
			$start->modify('+1 day');
			if ($year !== $start->format('Y')) $holidays = $this->holidays($start->format('Y'));
		}
		return $holiday_num;
	}

	/**
	 *               _
	 *   ___ ___ ___| |_
	 *  | . | . |_ -|  _|
	 *  |  _|___|___|_|
	 *  |_|
	 * @param array $columns
	 * 	[
	 * 	':type' => string,
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int | null,
	 * 	':organizational_unit' => str | null,
	 * 	':subject' => str | null,
	 * 	':misc' => str (e.g. UTILITY::json_encoded whatnot) | null,
	 * 	':closed' => str (e.g. UTILITY::json_encoded when, by whom) | null,
	 * 	':alert' => int 1 | null,
	 * 	':autodelete' => int 1 | null
	 * 	]
	 * @return int|bool insert id
	 */
	public function post($columns = []){
		if (SQLQUERY::EXECUTE($this->_pdo, 'calendar_post', [
			'values' => $columns
		])) return $this->_pdo->lastInsertId();
		return false;
	}
	
	/**
	 *           _
	 *   ___ _ _| |_
	 *  | . | | |  _|
	 *  |  _|___|_|
	 *  |_|
	 * @param array $columns
	 * 	[
	 * 	':id' => int
	 * 	type isn't supposed to change
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int | null,
	 * 	':organizational_unit' => str | null,
	 * 	':subject' => str | null,
	 * 	':misc' => str (e.g. UTILITY::json_encoded whatnot) | null,
	 * 	':closed' => str (e.g. UTILITY::json_encoded when, by whom) | null,
	 * 	':alert' => int 1 | null,
	 * 	':autodelete' => int 1 | null
	 * 	]
	 * @return int affected rows
	 */
	public function put($columns = []){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_put', [
			'values' => $columns
		]);
	}

	/**
	 *                 _
	 *   ___ ___ ___ _| |___ ___
	 *  |  _| -_|   | . | -_|  _|
	 *  |_| |___|_|_|___|___|_|
	 *
	 * renders a calendar view, for given date week starts on monday, month on 1st, weekday offsets are empty
	 * calculates holidays for every date for possible year overlaps in selected view-format
	 * 
	 * @param string $format month|week
	 * @param string $type schedule|timesheet
	 * @param string $date yyyy-mm-dd
	 * 
	 * @return array assemble.js calendar type
	 */
	public function render($format = '', $type = '', $date = '', ){
		$result = ['header' => null, 'content' => []];
		if (!$this->_days || $date) $this->days($format, $date);

		foreach ($this->_days as $day){
			if ($day === null) $result['content'][] = null;
			else {
				// count events relevant to user based on units
				$events = $this->getDay($day->format('Y-m-d'));
				$numbers = 0;
				foreach ($events as $row){
					if (!$row['organizational_unit']) $row['organizational_unit'] = ''; 
					$row['affected_user_units'] = $row['affected_user_units'] ? : $row['organizational_unit'];
					switch ($type){
						case 'schedule':
							if ($row['type'] === $type && array_intersect(explode(',', $row['organizational_unit']), ['common', ...$_SESSION['user']['units']]))
								if (!$row['closed'])
								$numbers++;
							break;
						case 'timesheet':
							if ($row['type'] === $type && array_intersect(explode(',', $row['affected_user_units']), ['common', ...$_SESSION['user']['units']]))
							$numbers++;
					}	
				}

				// construct information for day
				$result['content'][] = [
					'date' => $day->format('Y-m-d'),
					'display' => $this->_lang->_USER['general']['weekday'][$day->format('N')] . ' ' . $day->format('j') . ($numbers ? "\n" . $numbers : ''),
					'today' => $day->format('Y-m-d') === $this->_date['usertime']->format('Y-m-d'),
					'selected' => $date === $day->format('Y-m-d'),
					'holiday' => in_array($day->format('Y-m-d'), $this->holidays($day->format('Y'))) || !in_array($day->format('N'), $this->_workdays),
					'title' => $this->_lang->GET('calendar.daily_title', [':day' => $this->_lang->_USER['general']['weekday'][$day->format('N')] . ' ' . $this->dateFormat($day->format('Y-m-d')), ':number' => $numbers])
				];

				if ($result['header']) continue;
				// add header information 
				if ($format === 'week') $result['header'] = $this->_lang->GET('general.calendar_week', [':number' => $day->format('W')]) . ' ' . $day->format('Y');
				if ($format === 'month') $result['header'] = $this->_lang->_USER['general']['month'][$day->format('n')] . ' ' . $day->format('Y');
			}
		}
		return $result;
	}

	/**
	 *   _   _               _           _
	 *  | |_|_|_____ ___ ___| |_ ___ ___| |_ ___ _ _ _____ _____ ___ ___ _ _
	 *  |  _| |     | -_|_ -|   | -_| -_|  _|_ -| | |     |     | .'|  _| | |
	 *  |_| |_|_|_|_|___|___|_|_|___|___|_| |___|___|_|_|_|_|_|_|__,|_| |_  |
	 *                                                                  |___|
	 * calculates time and off-duty days summed up for users from beginning of a given month to the end of another given month
	 * overtime and vacation calculation only works if $from_date starts from the dawn of time
	 * so you might have to do two queries and combine their output,
	 * e.g. leftvacation and alltime overtime have to be calculated for the whole database timespan,
	 * pto might make sense for a given month only
	 * 
	 * @param array $users array of users with columns
	 * @param object|string $from_date DateTime|Y-m-d
	 * @param object|string $to_date DateTime|Y-m-d
	 * 
	 * @return array
	 * 	[
	 * 		[
	 *			'_id' => int,
	 *			'_name' => string,
	 *			'_units' => string,
	 *			'_weeklyhours' => array with start datetime and value,
	 *			'_span_end_weeklyhours' => int, // last applied due to given timespan
	 *			'_annualvacation' => array with start datetime and value,
	 *			'_leftvacation' => int,
	 *			'_projected' => float,
	 *			'_performed' => float,
	 *			'_overtime' => float,
	 *			'_pto' => array with datetime and value
	 *			...
	 * 			any pto days will be counted by their respective languagefile key as int
	 * 		],
	 * 		...
	 * 	]
	 */
	public function timesheetSummary($users = [], $from_date = '', $to_date = ''){
		// construct timespan
		$minuteInterval = new \DateInterval('PT1M');
		$from_date = gettype($from_date) === 'object' ? $from_date : new \DateTime($from_date ? : '1970-01-01');
		$from_date->modify('first day of this month')->setTime(0, 0);
		$to_date = gettype($to_date) === 'object' ? $to_date : new \DateTime($to_date ? : 'now');
		$to_date->modify('last day of this month')->setTime(23, 59, 59);

		$entries = $this->getWithinDateRange($from_date->format('Y-m-d H:i:s'), $to_date->format('Y-m-d H:i:s'));
		$result = [];
		// sort result span_start to process user-settings in the right order
		array_multisort(array_column($entries, 'span_start'), SORT_ASC, $entries);
		
		// prepare all users eligible for timetracking due to average weekly hours set
		foreach ($users as $row => $user){
			$user['app_settings'] = $users[$row]['app_settings'] = json_decode($user['app_settings'] ? : '', true);
			if (!$user['app_settings'] || !isset($user['app_settings']['weeklyhours']) || !$user['app_settings']['weeklyhours']){
				unset ($users[$row]);
				continue;
			}
			// prepare timesheet settings, use _ to avoid overwriting from dynamically prepared keys
			$users[$row]['timesheet'] = [
				'_id' => $user['id'],
				'_weeklyhours' => [],
				'_span_end_weeklyhours' => null, // last applied due to given timespan
				'_annualvacation' => [],
				'_leftvacation' => 0,
				'_projected' => 0,
				'_performed' => 0,
				'_overtime' => 0,
				'_initialovertime' => isset($user['app_settings']['initialovertime']) ? floatval(str_replace(',', '.', $user['app_settings']['initialovertime'])) : 0,
				'_pto' => []
			];

			// prepare occasionally changing contract settings
			// create array with start date of changes and applicable value
			foreach (['weeklyhours', 'annualvacation'] as $setting){
				$hours_vacation = [];
				if (isset($user['app_settings'][$setting])){
					$settingentries = explode('\n', $user['app_settings'][$setting]);
					natsort($settingentries);
					foreach ($settingentries as $line){
						// match ISO 8601 start date of contract settings, days of annual vacation or weekly hours
						preg_match('/(\d{4}.\d{2}.\d{2}).+?([\d,\.]+)/', $line, $lineentry);
						// append datetime value and contract value
						if ($line && isset($lineentry[1]) && isset($lineentry[2])) $hours_vacation[] = ['date' => new \DateTime($lineentry[1]), 'value' => floatval(str_replace(',', '.', $lineentry[2]))];
					}
				}
				if (!$hours_vacation) $hours_vacation[] = ['date' => new \DateTime('1970-01-01'), 'value' => 0];
				array_multisort(array_column($hours_vacation, 'date'), SORT_ASC, $hours_vacation);
				$users[$row]['timesheet']['_' . $setting] = $hours_vacation;
			}
		}
		// reindex for users without timetracking have been deleted
		$users = array_values($users);

		// process actual entries and contribute to user timesheet array
		foreach ($entries as $entry){
			if ($entry['type'] !== 'timesheet' || !in_array($entry['affected_user_id'], array_column($users, 'id'))) continue;
			$row = array_search($entry['affected_user_id'], array_column($users, 'id'));
			$user = $users[$row];

			// convert to datetime, limit to month boundaries if necessary
			$span_start = new \DateTime($entry['span_start']);
			if ($span_start < $from_date) $span_start = clone $from_date;
			$span_end = new \DateTime($entry['span_end']);
			if ($span_end > $to_date) $span_end = clone $to_date;

			// get breaks and homeoffice times
			$misc = json_decode($entry['misc'], true);

			if (!$entry['subject'] || !strlen($entry['subject'])) {
				
				// aka regular working day
				if (isset($user['timesheet']['_weeklyhours'][0]) && $span_start < $user['timesheet']['_weeklyhours'][0]['date']){
					// since entries are sorted by date, if dated earlier than the initial applied weeklyhours this can not be applicable
					continue;
				}
				// calculate and add hours
				$periods = new \DatePeriod($span_start, $minuteInterval, $span_end);
				$hours = iterator_count($periods) / 60;
				if (isset($misc['homeoffice'])) $hours += $this->timeStrToFloat($misc['homeoffice']);
				if (isset($misc['break'])) $hours -= $this->timeStrToFloat($misc['break']);
				if (isset($misc['workinghourscorrection'])) $hours += floatval(str_replace(',', '.', $misc['workinghourscorrection']));
				$users[$row]['timesheet']['_performed'] += $hours;
			} else {

				// off duty days
				$span_start->setTime(0, 0);
				$span_end->setTime(23, 59, 59);

				if (!$user['timesheet']['_annualvacation'] || $span_start < $user['timesheet']['_annualvacation'][0]['date']){
					// if setting is empty vacations are obviously not used by this user
					// since entries are sorted by date, if dated earlier than the last applied annualvacation this can not be applicable
					continue;
				}
				// all days within time span
				$days = intval($span_start->diff($span_end)->format('%a')) + 1;

				// create pto subset
				if (!isset($users[$row]['timesheet'][$entry['subject']])) $users[$row]['timesheet'][$entry['subject']] = 0;

				// reduce days by non working days
				$days -= $this->numberOfNonWorkdays($span_start, $span_end);

				// add calculated days for current pto event to user subset 
				$users[$row]['timesheet'][$entry['subject']] += $days;

				// add eligible pto to a dated array for below use
				if ($entry['subject'] !== 'timeoff') $users[$row]['timesheet']['_pto'][] = ['start' => $span_start, 'end' => $span_end, 'value' => $days];
			}
		}
		/** reiterate over users
		 * gather all projected working hours and set overtime += performed - projected
		 * gather all annual vacations and set leftvacation += allvacations - vacation
		 * outside of database for possibility of not having submitted entries
		 */
		foreach ($users as $row => $user){
			// accumulate projected hours for given timespan according to applicable contract settings at the respective time
			for($i = 0; $i < count($user['timesheet']['_weeklyhours']); $i++){
				// reassure timespan within contract settings
				$startdate = $user['timesheet']['_weeklyhours'][$i]['date'];
				if ($startdate > $to_date) break;
				if ($i === count($user['timesheet']['_weeklyhours']) - 1) $enddate = clone $to_date;
				else {
					$enddate = clone $user['timesheet']['_weeklyhours'][$i + 1]['date'];
					$enddate->modify('-1 day');
				}
				if ($enddate < $from_date) continue;
				if ($startdate < $from_date) $startdate = clone $from_date;
				$users[$row]['timesheet']['_span_end_weeklyhours'] = $user['timesheet']['_weeklyhours'][$i]['value'];

				// count all days within timespan
				$daynum = intval($startdate->diff($enddate)->format('%a')) + 1;

				// calculate non working days
				$holidays = $this->numberOfNonWorkdays($startdate, $enddate);

				// add reasonable pto to holiday count, that are not expected to contribute to projected
				foreach ($user['timesheet']['_pto'] as $pto){
					$ptostart = $pto['start'];
					$ptoend = $pto['end'];
					if ($ptostart >= $startdate && $ptoend <= $enddate) {
						$holidays += $pto['value'];
						continue;
					}
					if ($ptostart > $enddate || $ptoend < $startdate) continue;
					if ($ptostart < $startdate) $ptostart = $startdate;
					if ($ptoend > $enddate) $ptoend = $enddate;
					$ptonum = intval($ptostart->diff($ptoend)->format('%a')) + 1;
					if ($ptonum) $holidays += $pto['value'] - $ptonum;
				}

				// calculate projected hours
				$users[$row]['timesheet']['_projected'] += ($daynum - $holidays) * ($user['timesheet']['_weeklyhours'][$i]['value'] / count($this->_workdays));
			}

			// calculate overtime 
			$users[$row]['timesheet']['_overtime'] += $users[$row]['timesheet']['_performed'] - $users[$row]['timesheet']['_projected'];

			// accumulate annual vacation days always from the beginning of tracking according to applicable contract settings at the respective time
			$users[$row]['timesheet']['_leftvacation'] = isset($user['timesheet']['_annualvacation'][0]) ? $user['timesheet']['_annualvacation'][0]['value'] : 0;
			for($i = 1; $i < count($user['timesheet']['_annualvacation']); $i++){
				// reassure timespan within contract settings
				$startdate = $user['timesheet']['_annualvacation'][$i]['date'];
				if ($startdate > $to_date) break;
				$enddate = ($i === count($user['timesheet']['_annualvacation']) - 1) ? $to_date : $user['timesheet']['_annualvacation'][$i + 1]['date'];
				$annualstart = clone $startdate;
				$year = '';
				while ($annualstart < $enddate){
					if ($annualstart->format('Y') != $year){
						$users[$row]['timesheet']['_leftvacation'] += $user['timesheet']['_annualvacation'][$i]['value'];
						$year = $annualstart->format('Y');
					}
					$annualstart->modify('+1 month');
				}
			}
			if (isset($user['timesheet']['vacation'])) $users[$row]['timesheet']['_leftvacation'] -= $users[$row]['timesheet']['vacation'];
			$result[] = $users[$row]['timesheet'];
		}
		return $result;
	}

	/**
	 *   _   _               _       _       ___ _         _
	 *  | |_|_|_____ ___ ___| |_ ___| |_ ___|  _| |___ ___| |_
	 *  |  _| |     | -_|_ -|  _|  _|  _| . |  _| | . | .'|  _|
	 *  |_| |_|_|_|_|___|___|_| |_| |_| |___|_| |_|___|__,|_|
	 *
	 * returns a float from H:i format
	 * 
	 * @param string $string H:i
	 * 
	 * @return float
	 */
	public function timeStrToFloat($string){
		$string = explode(':', $string);
		return intval($string[0]) + (intval($string[1]) / 60);
	}

	/**
	 *                       _
	 *   ___ ___ ___ ___ ___| |_
	 *  |_ -| -_| .'|  _|  _|   |
	 *  |___|___|__,|_| |___|_|_|
	 *
	 * @param string $search
	 * @return array sql result
	 */
	public function search($search = ''){
		return SQLQUERY::EXECUTE($this->_pdo, 'calendar_search', [
			'values' => [
				':SEARCH' => $search
			],
			'wildcards' => true
		]);
	}
}
?>