<?php
// calendar
class CALENDARUTILITY {
	/**
	 * calendar handler writing to database and rendering either weeks or months for given date or now by default
	 * include to display calendar or use for scheduling and timesheets
	 * with hopefully well prepared date-handling
	 * 
	 * to avoid long parameter lists larger requiries will have to be passed as named arrays. this way calling scripts are supposed to be clearer.
	 * for transparency reasons these have to be well prepared as there is no default checking, thus may end in sql errors on purpose.
	 */

   	/**
	 * preset database connection, passed from main application
	 */
	private $_pdo = null;

   	/**
	 * displayed days for given date or default now, can be set through function days() and processed later on
	 * will be generated by function render() if not set or latter has been passed a date 
	 */
	public $_days = [];

	/**
	 * ini settings avoiding repetitive calls
	 */
	private $_holidays = [];
	private $_easter_holidays = [];
	public $_workdays = [];

	public function __construct($pdo){
		$this->_pdo = $pdo;
		$this->_holidays = preg_split('/[^\d-]+/', INI['calendar']['holidays']);
		$this->_easter_holidays = INI['calendar']['easter_holidays'];
		$this->_workdays = preg_split('/[^\d-]+/', INI['calendar']['workdays']);
	}

	/**
	 * calculates holidays for given year, according to setup.ini
	 * no setting up on construction for possible year overlaps on week rendering
	 * @param int $year Y
	 * @return array containing holiday dates for a given year
	 */
	public function holidays($year){
		$holidays = $this->_holidays;
		$holidays = array_map(Fn($d) => $year . '-'. $d, $holidays);

		$easter = new DateTime('now', new DateTimeZone(INI['timezone']));
		$easter->setTimestamp(easter_date($year));
		foreach($this->_easter_holidays as $day => $offset){
			$easterholiday = clone $easter;
			$easterholiday->modify(($offset < 0 ? '-' : '+') . $offset .' days');
			$holidays[] = $easterholiday->format('Y-m-d');
		}
		return $holidays;
	}

	/**
	 * calculates a calendar view, for given date week starts on monday, month on 1st
	 * 
	 * @param string $format month|week
	 * @param string $date yyyy-mm-dd
	 */
	public function days($format = '', $date = ''){
		$result = [];
		$date = new DateTime($date ? : 'now', new DateTimeZone(INI['timezone']));
		$date->setTime(0, 0);
		if ($format === 'week') {
			$date->modify('- ' . ($date->format('N') - 1) . ' days');
			while ($date->format('N') < 7){
				$result[] = clone $date;
				$date->modify('+1 days');
			}
			$result[] = $date;
		}
		elseif ($format === 'month') {
			$date->modify('first day of this month');
			if ($date->format('N') > 1){
				for ($i = 1; $i < $date->format('N'); $i++){
					$result[] = null;
				}
			}
			while ($date->format('j') < $date->format('t')) {
				$result[] = clone $date;
				$date->modify('+1 days');
			}
			$result[] = $date;
		}
		// ensure the last day lasts to midnight for time comparisons
		$last_day = clone $result[count($result) - 1];
		$last_day->modify('+23 hours')->modify('+59 seconds');
		$result[count($result) - 1] = $last_day;
		$this->_days = $result;
	}

	/**
	 * renders a calendar view, for given date week starts on monday, month on 1st, weekday offsets are empty
	 * calculates holidays for every date for possible year overlaps in selected view-format
	 * 
	 * @param string $format month|week
	 * @param string $type schedule|timesheet
	 * @param string $date yyyy-mm-dd
	 * 
	 * @return array assemble.js calendar type
	 */
	public function render($format = '', $type = '', $date = '', ){
		$result = ['header' => null, 'content' => []];
		if (!$this->_days || $date) $this->days($format, $date);

		$today = new DateTime('now', new DateTimeZone(INI['timezone']));
		foreach ($this->_days as $day){
			if ($day === null) $result['content'][] = null;
			else {
				$events = $this->getDay($day->format('Y-m-d'));
				$numbers = 0;
				foreach ($events as $row){
					switch ($type){
						case 'schedule':
							if ($row['type'] === $type && array_intersect(explode(',', $row['organizational_unit']), $_SESSION['user']['units']))
								if (!$row['closed'])
								$numbers++;
							break;
						case 'timesheet':
							if ($row['type'] === $type && array_intersect(explode(',', $row['affected_user_units']), $_SESSION['user']['units']))
							$numbers++;
					}	
				}
				$result['content'][] = [
					'date' => $day->format('Y-m-d'),
					'display' => LANGUAGEFILE['general']['weekday'][$day->format('N')] . ' ' . $day->format('j') . ($numbers ? "\n" . $numbers : ''),
					'today' => $day->format('Y-m-d') === $today->format('Y-m-d'),
					'selected' => $date === $day->format('Y-m-d'),
					'holiday' => in_array($day->format('Y-m-d'), $this->holidays($day->format('Y'))) || !in_array($day->format('N'), $this->_workdays)
				];
				if ($result['header']) continue;
				if ($format === 'week') $result['header'] = LANG::GET('general.calendar_week', [':number' => $day->format('W')]) . ' ' . $day->format('Y');
				if ($format === 'month') $result['header'] = LANGUAGEFILE['general']['month'][$day->format('n')] . ' ' . $day->format('Y');
			}
		}
		return $result;
	}

	/**
	 * returns an assemble.js dialog script to contribute to the calendar
	 * 
	 * @param array $columns, like put-method, but :type must be provided
	 * 	[
	 * 	':id' => int
	 * 	':type' => string schedule|timesheet
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int,
	 * 	':organizational_unit' => str,
	 * 	':subject' => str,
	 * 	':misc' => str (e.g. json_encoded whatnot),
	 * 	':closed' => str (e.g. json_encoded when, by whom),
	 * 	':alert' => int 1|0
	 * 	]
	 * @return string dialog script
	 */
	public function dialog($columns = []){
		if (!array_key_exists(':type', $columns)) return;
		// fill up default values
		foreach([':span_start', ':span_end', ':organizational_unit', ':subject', ':misc', 'closed'] as $str) if (!array_key_exists($str, $columns)) $columns[$str] = '';
		foreach([':id', ':alert'] as $int) if (!array_key_exists($int, $columns)) $columns[$int] = 0;
		foreach([':author_id', ':affected_user_id'] as $user) if (!array_key_exists($user, $columns)) $columns[$user] = $_SESSION['user']['id'];

		// prepare lists and datetime types for modification 
		$units = [];
		foreach(LANGUAGEFILE['units'] as $unit => $description){
			$units[$description] = in_array($unit, explode(',', $columns[':organizational_unit'])) ? ['checked' => true, 'value' => 'unit'] : ['value' => 'unit'];
		}

		$affected_users = $affected_unit_users = [];
		$statement = $this->_pdo->prepare(SQLQUERY::PREPARE('user_get-datalist'));
		$statement->execute();
		$users = $statement->fetchAll(PDO::FETCH_ASSOC);
		// unset system user
		array_splice($users, array_search(1, array_column($users, 'id')), 1);
		// set self to top 
		$self = array_splice($users, array_search($_SESSION['user']['id'], array_column($users, 'id')), 1);
		array_splice($users, 0, 0, $self);
		foreach($users as $user){
			$affected_users[$user['name']] = ($columns[':affected_user_id'] === $user['id']) ? ['value' => $user['id'], 'selected' => true] : ['value' => $user['id']];
			if (array_intersect(explode(',', $user['units']), $_SESSION['user']['units'])) $affected_users[$user['name']] = ($columns[':affected_user_id'] === $user['id']) ? ['value' => $user['id'], 'selected' => true] : ['value' => $user['id']];
		}

		$alert = $span_start = $span_end = null; 
		$alert = [LANG::GET('calendar.event_alert') => $columns[':alert'] ? ['checked' => true] : []];
		
		if ($columns[':span_start']) $span_start = new DateTime($columns[':span_start'], new DateTimeZone(INI['timezone']));
		else $span_start = new DateTime('now', new DateTimeZone(INI['timezone']));

		switch ($columns[':type']){
			case 'schedule':
				if ($columns[':span_end']) $span_end = new DateTime($columns[':span_end'], new DateTimeZone(INI['timezone']));
				else {
					$span_end = clone $span_start;
					$span_end->modify('+' . INI['calendar']['default_due'] . ' days');
				}
				$inputs = [
					[
						'type' => 'scanner',
						'attributes' => [
							'name' => LANG::GET('calendar.event_content'),
							'value' => $columns[':subject'],
							'required' => true
						]
					],
					[
						'type' => 'dateinput',
						'attributes' => [
							'name' => LANG::GET('calendar.event_date'),
							'value' => $span_start->format('Y-m-d'),
							'required' => true
						]
					],
					[
						'type' => 'dateinput',
						'attributes' => [
							'name' => LANG::GET('calendar.event_due'),
							'value' => $span_end->format('Y-m-d'),
							'required' => true
						]
					],
					[
						'type' => 'checkbox',
						'description' => LANG::GET('calendar.event_organizational_unit'),
						'content' => $units,
						'hint' => LANG::GET('calendar.event_organizational_unit_hint')
					],
					[
						'type' => 'checkbox',
						'description' => LANG::GET('calendar.event_alert_description'),
						'content' => $alert
					],
					[
						'type' => 'hiddeninput',
						'attributes' => [
							'name' => LANG::GET('calendar.event_type'),
							'value' => $columns[':type']
						]
					],
					[
						'type' => 'hiddeninput',
						'attributes' => [
							'name' => 'calendarEventId',
							'value' => $columns[':id'],		
						]
					]
				];
				break;
			case 'timesheet':
				if ($columns[':span_end']) $span_end = new DateTime($columns[':span_end'], new DateTimeZone(INI['timezone']));
				else {
					$span_end = clone $span_start;
					$span_end->modify('+1 hour');
				}
		
				$misc = $columns[':misc'] ? json_decode($columns[':misc'], true) : [];
				
				$ptoselect = [];
				foreach(LANGUAGEFILE['calendar']['timesheet_pto'] as $subject => $reason){
					$ptoselect[$reason] = ['value' => $subject];
					if ($columns[':subject'] === $subject) $ptoselect[$reason]['selected'] = true;
				}

				$inputs = [];

				if (array_intersect(['admin', 'ceo', 'humanressources'], $_SESSION['user']['permissions'])){
					$inputs[] = [
						'type' => 'select',
						'content' => $affected_users,
						'attributes' => [
							'name' => LANG::GET('calendar.event_affected_user')
						]
					];
				} elseif (array_intersect(['supervisor'], $_SESSION['user']['permissions']) && array_intersect(explode(',', $row['affected_user_units']), $_SESSION['user']['units'])){
					$inputs[] = [
						'type' => 'select',
						'content' => $affected_unit_users,
						'attributes' => [
							'name' => LANG::GET('calendar.event_affected_user')
						]
					];
				} else {
					$inputs[] = [
						'type' => 'hiddeninput',
						'attributes' => [
							'name' => LANG::GET('calendar.event_affected_user'),
							'value' => $columns[':affected_user_id']
						]
					];
				}
				// name => required bool
				$setFieldVisibility = [
					LANG::GET('calendar.timesheet_start_time') => true,
					LANG::GET('calendar.timesheet_end_time') => true,
					LANG::GET('calendar.timesheet_break_time') => true,
					LANG::GET('calendar.timesheet_homeoffice') => true
				];
				array_push($inputs, ...[
					[
						'type' => 'select',
						'attributes' => [
							'name' => LANG::GET('calendar.timesheet_pto_exemption'),
							'onchange' => "calendarClient.setFieldVisibilityByNames('" . json_encode($setFieldVisibility) . "', this.value === LANG.GET('calendar.timesheet_pto.regular'))"
						],
						'content' => $ptoselect
					],[
						'type' => 'dateinput',
						'attributes' => [
							'name' => LANG::GET('calendar.timesheet_start_date'),
							'value' => $span_start->format('Y-m-d'),
							'required' => true
						]
					],[
						'type' => 'timeinput',
						'attributes' => [
							'name' => LANG::GET('calendar.timesheet_start_time'),
							'value' => $span_start->format('H:i'),
							'required' => true
						]
					],[
						'type' => 'dateinput',
						'attributes' => [
							'name' => LANG::GET('calendar.timesheet_end_date'),
							'value' => $span_end->format('Y-m-d'),
							'required' => true
						]
						],[
							'type' => 'timeinput',
							'attributes' => [
								'name' => LANG::GET('calendar.timesheet_end_time'),
								'value' => $span_end->format('H:i'),
								'required' => true
							]
						],[
							'type' => 'timeinput',
							'attributes' => [
								'name' => LANG::GET('calendar.timesheet_break_time'),
								'value' => array_key_exists('break', $misc) ? $misc['break'] : '',
								'required' => true
							]
						],[
							'type' => 'textinput',
							'attributes' => [
								'name' => LANG::GET('calendar.timesheet_pto_note'),
								'value' => array_key_exists('note', $misc) ? $misc['note'] : '',
							]
						],[
							'type' => 'checkbox',
							'description' => LANG::GET('calendar.event_alert_description'),
							'content' => $alert
						],[
							'type' => 'hiddeninput',
							'attributes' => [
								'name' => 'calendarEventId',
								'value' => $columns[':id']
							]
						]
					]);
				if (array_key_exists('homeoffice', $_SESSION['user']['app_settings']) && $_SESSION['user']['app_settings']['homeoffice'])
					array_splice($inputs, 7, 0, [
						[
							'type' => 'timeinput',
							'attributes' => [
								'name' => LANG::GET('calendar.timesheet_homeoffice'),
								'value' => array_key_exists('homeoffice', $misc) ? $misc['homeoffice'] : '',
								'required' => true
							]
						]
					]);
				break;
		}

		return "new Dialog({type:'input', header: '', body: " . json_encode($inputs) . ", options:{'" . LANG::GET('calendar.event_cancel') . "': false, '" . LANG::GET('calendar.event_submit') . "': {'value': true, class: 'reducedCTA'}}})" .
			".then(response => {if (response) {calendarClient.createFormData(response); api.calendar('" . ($columns[':id'] ? 'put': 'post') . "', '" . $columns[':type'] . "');}})";
	}

	/**
	 * calculates time and off-duty days for users from beginning of a given month to the end of another given month
	 * overtime and vacation calculation only works if $from_date starts from the dawn of time
	 * so you might have to do two queries and combine their output,
	 * e.g. leftvacation and overtime have to be calculated for the whole database timespan,
	 * pto might make sense for a given month only
	 * 
	 * @param array $ids array of user ids
	 * @param object|string $from_date DateTime|Y-m-d
	 * @param object|string $to_date DateTime|Y-m-d
	 * 
	 * @return array
	 * 	[
	 * 		user_id => [
	 * 			'overtime' => float,
	 * 			'leftvacation' => int,
	 * 			'performed' => float,
	 * 			...
	 * 			any pto days will be counted by their respective languagefile key
	 * 		]
	 * 	]
	 */
	public function calculateTimesheets($ids = [], $from_date = '', $to_date = ''){
		$datetimezone = new DateTimeZone(INI['timezone']);
		$minuteInterval = new DateInterval('PT1M');
		$from_date = new DateTime($from_date ? : '1900-01-01', $datetimezone);
		$from_date->modify('first day of this month');
		$from_date->setTime(0, 0);
		$to_date = new DateTime($to_date ? : 'now', $datetimezone);
		$to_date->modify('last day of this month');
		$to_date->setTime(24, 00);
		$entries = $this->getWithinDateRange($from_date->format('Y-m-d H:i:s'), $to_date->format('Y-m-d H:i:s'));
		$result = $usersetting = [];
		// sort result span_start to process user-settings in the right order
		array_multisort(array_column($entries, 'span_start'), SORT_ASC, $entries);
		
		/**
		 * @param datetime $start
		 * @param datetime $end
		 * 
		 * @return int number of holdays within timespan
		 */
		function holidays($start, $end){
				// subtract holidays and weekends
				$holiday_num = 0;
				$holidays = $this->holidays($start->format('Y'));
				while ($start < $end){
					$year = $start->format('Y');
					if (in_array($start->format('Y-m-d'), $holidays) || !in_array($start->format('N'), $this->_workdays)) $holiday_num++;
					$start->modify('+1 day');
					if ($year !== $start->format('Y')) $holidays = $this->holidays($start->format('Y'));
				}
				return $holiday_num;
		}

		foreach ($entries as $entry){
			if ($entry['type'] !== 'timesheet' || !in_array($entry['affected_user_id'], $ids)) continue;
			$userid = $entry['affected_user_id']; // shortening
			// buffer user settings to avoid repeatedly reading and decoding
			if (!array_key_exists($userid, $usersetting)) {
				$settings = json_decode($entry['app_settings'], true);
				$usersetting[$userid] = ['current' => ['year' => 0, 'month' => 0]];
				/**[
				 * 		'initialovertime' => float,
				 * 		'weeklyhours' => array [datetime, float],
				 * 		'lastappliedweeklyhours' => int,
				 * 		'annualvacation' => array [datetime, float],
				 * 		'lastappliedannualvacation' => int,
				 * 		'current' => ['year' => int] // track to apply annual vacation
				 * ]*/

				if (array_key_exists('initialovertime', $settings)){
					$usersetting[$userid]['initialovertime'] = floatval(str_replace(',', '.', $settings['initialovertime']));
				} else $usersetting[$userid]['initialovertime'] = 0;

				foreach(['weeklyhours', 'annualvacation'] as $setting){
					$hours_vacation = [];
					// extract by start date, sort and try to find the first applicable setting
					if (array_key_exists($setting, $settings)){
						$settingentries = explode(';', $settings[$setting]);
						natsort($settingentries);
						foreach($settingentries as $line){
							preg_match('/(\d{4}\-\d{2}\-\d{2}).+?([\d,\.]+)/', $line, $lineentry);
							$hours_vacation[] = ['date' => new DateTime($lineentry[1], $datetimezone), 'value' => floatval(str_replace(',', '.', $lineentry[2]))];
						}
					} else $hours_vacation = ['date' => new DateTime('1900-01-01', $datetimezone), 'value' => 0];
					array_multisort(array_column($hours_vacation, 'date'), SORT_ASC, $hours_vacation);
					$usersetting[$userid][$setting] = $hours_vacation;

					$usersetting[$userid]['lastapplied' . $setting] = 0;
				}
			}
			if (!array_key_exists($userid, $result)) $result[$userid] = [
				'overtime' => $usersetting[$userid]['initialovertime'],
				'leftvacation' => $usersetting[$userid]['annualvacation'][0]['value'],
				'performed' => 0
			];

			// convert to datetime, limit to month boundaries if necessary
			$span_start = new DateTime($entry['span_start'], $datetimezone);
			if ($span_start < $from_date) $span_start = $from_date;
			$span_end = new DateTime($entry['span_end'], $datetimezone);
			if ($span_end > $to_date) $span_end = $to_date;

			// get breaks and homeoffice times
			$misc = json_decode($entry['misc'], true);

			if (!strlen($entry['subject'])) {
				if (!$usersetting[$userid]['weeklyhours'] || $span_start < $usersetting[$userid]['weeklyhours'][$usersetting[$userid]['lastappliedweeklyhours']]['date']){
					// if setting is empty timesheets are obviously not used by this user
					// since entries are sorted by date, if dated earlier than the last applied weeklyhours this can not be applicable
					continue;
				} else {
					// if greater than that check the next applicable setting
					foreach($usersetting[$userid]['weeklyhours'] as $i => $line){
						if ($line['date'] > $from_date) break;
						$usersetting[$userid]['lastappliedweeklyhours'] = $i;
					}
				}
				// calculate hours
				$periods = new DatePeriod($span_start, $minuteInterval, $span_end);
				$hours = iterator_count($periods) / 60;
				if (array_key_exists('homeoffice', $misc)) $hours += $this->timeStrToFloat($misc['homeoffice']);
				if (array_key_exists('break', $misc)) $hours -= $this->timeStrToFloat($misc['break']);

				$holidays = holidays($span_start, $span_end);
				$daynum = $span_start->diff($span_end)->format('a') + 1;
				$projected = $usersetting[$userid]['weeklyhours'][$usersetting[$userid]['lastappliedweeklyhours']]['value'] / 7 * ($daynum - $holidays);
				// add counted hours, subtract projected daily hours
				$result[$userid]['performed'] += $hours - $projected;
				$result[$userid]['overtime'] += $hours - $projected;
			} else {
				// count off duty days
				$span_start->setTime(0, 0);
				$span_end->setTime(24, 00);

				if (!$usersetting[$userid]['annualvacation'] || $span_start < $usersetting[$userid]['annualvacation'][$usersetting[$userid]['lastappliedannualvacation']]['date']){
					// if setting is empty timesheets are obviously not used by this user
					// since entries are sorted by date, if dated earlier than the last applied annualvacation this can not be applicable
					continue;
				} else {
					// if greater than that check the next applicable setting
					foreach($usersetting[$userid]['annualvacation'] as $i => $line){
						if ($line['date'] > $from_date) break;
						$usersetting[$userid]['lastappliedannualvacation'] = $i;
					}
					// if year changes add leftvacation by applicable value
					if ($span_start->format('Y') !== $usersetting[$userid]['current']['year']){
						$result[$userid]['leftvacation'] += $usersetting[$userid]['annualvacation'][$usersetting[$userid]['lastappliedannualvacation']]['value'];
						$usersetting[$userid]['current']['year'] = $span_start->format('Y');
					}
				}

				$periods = new DatePeriod($span_start , $minuteInterval, $span_end);
				$days = iterator_count($periods) / (60 * 24);
				if (!array_key_exists($entry['subject'], $result[$userid])) $result[$userid][$entry['subject']] = 0;

				$days -= holidays($span_start, $span_end);

				$result[$userid][$entry['subject']] += $days;
				if ($entry['subject'] === 'vacation') $result[$userid]['leftvacation'] -= $days;
			}
		}
		var_dump($result);
	}

	/**
	 * returns a float from H:i format
	 * 
	 * @param string $string H:i
	 * 
	 * @return float
	 */
	public function timeStrToFloat($string){
		$string = explode(':', $string);
		return intval($string[0]) + (intval($string[1]) / 60);
	}

	/**
	 * get all events where passed date is within span_start and span_end
	 * this results in all currently happening events
	 * 
	 * @param string $date Y-m-d
	 * @return array sql result
	 */
	public function getDay($date = ''){
		$statement = $this->_pdo->prepare(SQLQUERY::PREPARE('calendar_get-day'));
		$statement->execute([
			':date' => $date
		]);
		return $statement->fetchAll(PDO::FETCH_ASSOC);
	}

	/**
	 * @return array sql result
	 */
	public function alert(){
		$statement = $this->_pdo->prepare(SQLQUERY::PREPARE('calendar_alert'));
		$statement->execute([
		]);
		return $statement->fetchAll(PDO::FETCH_ASSOC);
	}

	/**
	 * get all events where span_start or span_end are within passed timespan 
	 * 
	 * @param string $earlier Y-m-d | null
	 * @param string $later Y-m-d | null
	 * @return array sql result
	 */
	public function getWithinDateRange($earlier = '', $later = ''){
		$statement = $this->_pdo->prepare(SQLQUERY::PREPARE('calendar_get-within-date-range'));
		$statement->execute([
			':earlier' => $earlier ? : '1900-01-01 00:00:01',
			':later' => $later ? : '2079-06-06 23:59:59'
		]);
		return $statement->fetchAll(PDO::FETCH_ASSOC);
	}

	/**
	 * @param string $search
	 * @return array sql result
	 */
	public function search($search = ''){
		$statement = $this->_pdo->prepare(SQLQUERY::PREPARE('calendar_search'));
		$statement->execute([
			':subject' => $search
		]);
		return $statement->fetchAll(PDO::FETCH_ASSOC);
	}

	/**
	 * @param array $columns
	 * 	[
	 * 	':type' => string,
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int,
	 * 	':organizational_unit' => str,
	 * 	':subject' => str,
	 * 	':misc' => str (e.g. json_encoded whatnot),
	 * 	':closed' => str (e.g. json_encoded when, by whom),
	 * 	':alert' => int 1|0
	 * 	]
	 * @return int|bool insert id
	 */
	public function post($columns = []){
		$statement = $this->_pdo->prepare(SQLQUERY::PREPARE('calendar_post'));
		if ($statement->execute($columns)) return $this->_pdo->lastInsertId();
		return false;
	}

	/**
	 * @param array $columns
	 * 	[
	 * 	':id' => int
	 * 	type isn't supposed to change
	 * 	':span_start' => string Y-m-d H:i:s,
	 * 	':span_end' => string Y-m-h H:i:s,
	 * 	':author_id' => int,
	 * 	':affected_user_id' => int,
	 * 	':organizational_unit' => str,
	 * 	':subject' => str,
	 * 	':misc' => str (e.g. json_encoded whatnot),
	 * 	':closed' => str (e.g. json_encoded when, by whom),
	 * 	':alert' => int 1|0
	 * 	]
	 * @return int affected rows
	 */
	public function put($columns = []){
		$statement = $this->_pdo->prepare(SQLQUERY::PREPARE('calendar_put'));
		$statement->execute($columns);
		return $statement->rowCount();
	}

	/**
	 * @param str $id eventually comma separated multiple ints
	 * @param any $close boolval false will clear
	 * @param any $alert null remains state, bool updates
	 * @return int affected rows
	 */
	public function complete($id = '0', $close = null, $alert = null){
		if ($close) $close = ['user' => $_SESSION['user']['name'], 'date' => date('Y-m-d')];
		$ids = explode (',', $id);
		$sqlchunks = [];
		$affected_rows = 0;
		$query = strtr(SQLQUERY::PREPARE('calendar_get-by-id'), [':id' => implode(",", array_map(Fn($id) => $this->_pdo->quote($id), $ids))]);
		$statement = $this->_pdo->prepare($query);
		$statement->execute();
		$entries = $statement->fetchAll(PDO::FETCH_ASSOC);
		foreach ($entries as $entry){
			$sqlchunks = SQLQUERY::CHUNKIFY($sqlchunks, strtr(SQLQUERY::PREPARE('calendar_complete'),
				[
					':id' => $this->_pdo->quote($entry['id']),
					':closed' => $this->_pdo->quote($close ? json_encode($close) : ''),
					':alert' => $alert === null ? $entry['alert'] : intval($alert)
				]
			));
		}
		foreach ($sqlchunks as $chunk){
			$statement = $this->_pdo->prepare($chunk);
			try {
				if ($statement->execute()) $affected_rows += $statement->rowCount();
			}
			catch (Exception $e) {
				echo $e, $chunk;
				die();
			}
		}
		return $affected_rows;
	}

	/**
	 * @param int $id
	 * @return int affected rows
	 */
	public function delete($id = 0){
		$statement = $this->_pdo->prepare(SQLQUERY::PREPARE('calendar_delete'));
		$statement->execute([
			':id' => $id
		]);
		return $statement->rowCount();
	}
}
?>